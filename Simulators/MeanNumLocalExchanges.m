function [ num_minavg,v_numMin] = MeanNumLocalExchanges( num_MCIterations , graphGenerator , dim_subspace, snr , max_localExchanges ,max_error, inputEstimator)
% Description: Monte Carlo simulation for obtaining the minimum number of
% iterations in a subspace generated by orthonormalizing a uniformly iid
% collection of numNodes x subspaceDim matrices. The estimators must be implemented in a
% decentralized fashion.
%
%
% INPUT:
%   num_MCiterations : number of Monte Carlo iterations
%   num_nodes : number of nodes in the network
%   graphGenerator  : an object of class Graph
%   dim_subspace : dimension of the subspace containing the data
%   snr :  ratio of the power of each signal vector entry to the power of each
%          noise vector entry [natural units].
%   max_localExchanges : the maximum number of times a node shares its estimate with its
%              neighbors.
%   max_error= the maximum error
%   estimator : is an obect that inherits from
%               DecentralizedProectionEstimator
%
% OUTPUT:
%   num_minavg : The minimum number of iteration that we need to achieve norm(m_signalEstimates-signal)^2/norm(signal)^2<=max_error

%input processing
v_numMin=zeros(1,num_MCIterations);
% Monte Carlo loop
for ind_MCIteration = 1:num_MCIterations
	% Generate the graph
	graph = graphGenerator.realization();
	
	% Generate the subspace and its orthogonal subspace
	[m_basisSubspace,~]=qr(rand(graph.getNumberOfNodes(),dim_subspace),0);
	
	% Generate the (noisy) signal
	signalCoordinates = randn(dim_subspace,1);
	signal = sqrt(snr)*sqrt(graph.getNumberOfNodes()/dim_subspace)*m_basisSubspace*signalCoordinates;
	noise = randn(graph.getNumberOfNodes(),1);
	noisySignal = signal + noise;
	
	% find the minimum number of iterations that we need to achieve norm(m_signalEstimates-signal)^2/norm(signal)^2<=max_error
	% Estimation for all methods
	m_signalEstimates = ... 	%  m_signalEstimates is num_nodes x num_localExchanges
		inputEstimator.estimate(noisySignal,m_basisSubspace,graph,max_localExchanges);
	
	%algorithm
	m_differ=m_signalEstimates-signal*ones(1,size(signal,1));
	v_differ=sum(m_differ.^2,1);
	v_differ=v_differ./norm(signal)^2;
	num_min=find(v_differ<=max_error);
	if size(num_min,2)<1
		num_min(1)=max_localExchanges;
	end
	v_numMin(ind_MCIteration)=num_min(1);
end
% Obtain the average of the minimum number of iterations
num_minavg = mean( v_numMin);
end
